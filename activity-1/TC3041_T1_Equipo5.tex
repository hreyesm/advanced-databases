\documentclass[acmsmall]{acmart}

\usepackage{graphicx}  % for images
\usepackage{listings}

\AtBeginDocument{%
  \providecommand\BibTeX{{%
    \normalfont B\kern-0.5em{\scshape i\kern-0.25em b}\kern-0.8em\TeX}}}

\setcopyright{acmcopyright}
\copyrightyear{2021}
\acmYear{2021}

\acmJournal{JACM}
\acmMonth{1}

\begin{document}

\title{Actividad 1. Bases de datos en memoria}

\author{Daniela Vignau León}
\affiliation{%
  \institution{Tecnológico de Monterrey}
  \country{México}}

\author{Cristopher Cejudo}
\affiliation{%
  \institution{Tecnológico de Monterrey}
  \country{México}}

\author{Héctor Reyes}
\affiliation{%
  \institution{Tecnológico de Monterrey}
  \country{México}}

\renewcommand{\shortauthors}{Daniela Vignau, Cristopher Cejudo, Héctor Reyes}

\begin{abstract}
  Este reporte busca profundizar en varios aspectos de las bases de datos en memoria, teniendo como foco el sistema de administración de bases de datos (DBMS) Kinetica. También se analiza el rendimiento de la base de datos en cuestión para las operaciones de inserción y consulta.
\end{abstract}

\maketitle

\section{Introducción}
Kinetica es una base de datos distribuida en memoria que permite ingerir, analizar y visualizar datos simultáneamente. Es un DBMS único en el sentido de que aprovecha el rendimiento de la unidad de procesamiento gráfico (GPU) para realizar operaciones con más rapidez que las bases de datos tradicionales.

Al tratarse de una base de datos orientada a columnas diseñada para el procesamiento analítico (OLAP), Kinetica está optimizada para manejar grandes volúmenes de datos de alta cardinalidad. Por tanto, no es adecuada como sistema de uso transaccional (OLTP). Kinetica organiza los datos de forma estructurada, similar a otras bases de datos relacionales, y los almacena en la memoria RAM o vRAM, en el caso de las GPUs.

\section{Desarrollo}

\subsection{Arquitectura del DBMS}
\begin{figure}[ht]
temp  \includegraphics[width=75mm, scale=0.5]{./images/dbms-architecture.jpg}
  \caption{Arquitectura del DBMS}
  \label{fig:Arquitectura del DBMS}
\end{figure}

Kinetica cuenta con una arquitectura distribuida diseñada así para el procesamiento de datos a escala. Un clúster de Kinetica, conformado por nodos idénticos, es capaz de ejecutarse en hardware básico, así como en aquellos equipados con GPU. Uno de esos nodos es seleccionado para ser el nodo de agregación principal. En la Fig. \ref{fig:Arquitectura del DBMS} se muestra un diagrama de la arquitectura de Kinetica.

\subsection{Tipo de almacenamiento utilizado}
La interfaz API nativa a Kinetica para el almacenamiento de datos es de tipo objeto; cada uno de ellos es una fila en la tabla.

\subsection{Representación en memoria}
Dado que el tipo de almacenamiento utilizado por Kinetica es por columnas, la representación en memoria es secuencial. Así, cada registro de una columna va después del otro, e inmediatamente después de terminar esa columna, comienza la siguiente.

\subsection{Mecanismos de compresión}

Es posible aplicar diferentes mecanismos de compresión a las columnas de las tablas de Kinetica. De manera predeterminada, las columnas son almacenadas sin compresión. En el caso de que se compriman, permanecen en ese estado hasta que son utilizadas. Cuando se recuperan los datos, se realiza una copia temporal de los datos descomprimidos, la cual es descartada una vez que ya no se utiliza.

Kinetica admite cuatro configuraciones de compresión diferentes que varían en velocidad:

\begin{itemize}
  \item Ninguna (predeterminado)
  \item \verb|snappy|: Altas velocidades de compresión y descompresión. 
  \item \verb|lz4|: Alta velocidad de compresión, mayor velocidad de descompresión.
  \item \verb|lz4hc|: Menores velocidades de compresión y descompresión.
\end{itemize}

\subsection{Particionamiento}
Los datos de una tabla pueden ser sometidos a un particionamiento para optimizar el rendimiento y el manejo de datos. Los esquemas de particionamiento permitidos en Kinetica son los siguientes:

\begin{itemize}
  \item Rango: Las {\itshape particiones por rango} de datos se definen a partir de un rango donde todos los registros con una {\itshape llave de partición} de ese rango son asignados a esa {\itshape partición}.
  \item Intervalo: Las {\itshape particiones por intervalo} se definen como intervalos numéricos o intervalos basados en el tiempo. Todos los registros cuya {\itshape llave de partición} está dentro del intervalo, o en el rango inferior, son asignados a esa {\itshape partición}.
  \item Lista: Las {\itshape particiones por lista} pueden ser manuales o automáticas, donde, en general, cuando los registros cuyos valores de la {\itshape llave de partición} estén dentro de la lista prefinida, son asignados a esa {\itshape partición}.
  \item Hash: Las {\itshape particiones por hash} se definen por un número exacto de particiones, donde cada uno de los registros es asignado a una {\itshape partición} basado en el hash de la {\itshape llave de partición}.
  \item Series: El{\itshape particionamiento por serie} segmenta los datos en una secuencia de {\itshape particiones} alocadas de manera dinámica.
\end{itemize}

\subsection{Operaciones DML}
En lo que respecta a la inserción de datos (INSERT), Kinetica admite dos tipos de formato:

\begin{itemize}
  \item \verb|INSERT INTO...VALUES|: Se utiliza para insertar registros con valores literales en una tabla.
  \begin{lstlisting}
    INSERT INTO example.employee (
      id,
      dept_id,
      manager_id,
      first_name,
      last_name,
      sal,
      hire_date)
    VALUES
        (1, 1, null, 'Anne', 'Arbor', 200000, '2000-01-01')
  \end{lstlisting}
  \item \verb|INSERT INTO...SELECT|: Se utiliza para insertar registros de una tabla existente.
  \begin{lstlisting}
    INSERT INTO example.employee (
      id,
      dept_id,
      manager_id,
      first_name,
      last_name,
      sal)
    SELECT id, dept_id, manager_id, first_name, last_name, sal
    FROM example.employee
    WHERE hire_date >= '2000-01-01'
  \end{lstlisting}
\end{itemize}

De forma predeterminada, Kinetica descartará cualquier registro a insertar cuya llave primaria coincida con la de un registro existente.

Por otro lado, la operación de actualización (UPDATE) permite asignar un nuevo valor constante a una columna mediante el formato \verb|UPDATE...SET...WHERE|.

\begin{lstlisting}
  UPDATE example.employee
  SET
    sal = sal * 1.10,
    manager_id = 3
  WHERE id = 5
\end{lstlisting}

Finalmente, la operación de eliminación (DELETE) permite eliminar registros de una tabla mediante el formato \verb|DELETE FROM...WHERE|.

\begin{lstlisting}
  DELETE
  FROM example.employee
  WHERE id = 6
\end{lstlisting}

\subsection{Buffer diferencial y proceso de mezcla}


\subsection{Reconstrucción de tuplas}
\subsection{Tipos de {\itshape join}}

Con Kinetica, es posible conectar datos relacionados entre dos o más tablas a través de {\itshape join views}. Los tipos de {\itshape join} permitidos son:

\begin{itemize}
  \item INNER: Regresa los registros que coinciden entre dos tablas.
  \item LEFT:  Regresa los registros que coinciden entre dos tablas, así como también los registros de la {\itshape tabla izquierda} cuyos registros no coinciden con la tabla derecha.
  \item RIGHT: Regresa los registros que coinciden entre dos tablas, así como también los registros de la {\itshape tabla derecha} cuyos registros no coinciden con la tabla izquierda.
  \item FULL OUTER: Regresa los registros que coinciden entre dos tablas, así como aquellos que no tienen ninguna relación con la otra tabla.
  \item Cross: Regresa todos los registros de una tabla junto con su correspondiente registro de la otra tabla.
\end{itemize}

De igual manera, hay dos tipos de ejecución para los {\itshape joins}:

\begin{itemize}
  \item {\itshape Native joins}: Realiza un aislamiento de la operación {\itshape join} y crea un {\itshape join view} nativo de Kinetica. 
  \item SQL {\itshape Joins}: Se realiza de manera automática cuando una base de datos recibe una query de SQL con la cláusula \verb|JOIN|. 
\end{itemize}

Dependiendo del tipo de {\itshape join} utilizado, la memoria tiene un cierto impacto negativo. Kinetica constatemente busca la manera de crear el {\itshape join} más eficiente posible. 

\subsection{Logging}
Kinetica cuenta con un registro el cual almacena información como: las interacciones de la base de datos, {\itshape startup/shutdown}, información de errores y más. Este registro puede ser configurado para que se almacene otra información que no está por default.

\subsection{Respaldos y {\itshape Recovery}}

Existe una herramienta para la administración, configuración e instalación de Kinetica llamada {\itshape KAgent}, la cual también permite simplificar el proceso de respaldo y {\itshape recovery} de una base de datos en Kinetica. 

Todos los datos dentro de la base de datos pueden ser respaldados de manera automática (es decir, siguiendo una agenda preestablecida), o bien cuando el usuario así lo requiera. Los respaldos son almacenados de manera local para cada uno de los nodos dentro del cluster.

\subsection{Manejo de transacciones}
\subsection{Cold/hot store}
\subsection{Manejo de datos históricos}

% Pendiente

\end{document}
\endinput
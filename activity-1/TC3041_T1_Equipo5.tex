\documentclass[acmsmall]{acmart}

\usepackage{listings}

\AtBeginDocument{%
  \providecommand\BibTeX{{%
    \normalfont B\kern-0.5em{\scshape i\kern-0.25em b}\kern-0.8em\TeX}}}

\setcopyright{acmcopyright}
\copyrightyear{2021}
\acmYear{2021}

\acmJournal{JACM}
\acmMonth{1}

\begin{document}

\title{Actividad 1. Bases de datos en memoria}

\author{Daniela Vignau}
\email{a01021698@itesm.mx}
\affiliation{%
  \institution{Tecnológico de Monterrey}
  \city{Ciudad de México}
  \country{México}}

\author{Cristopher Cejudo}
\email{a01025468@itesm.mx}
\affiliation{%
  \institution{Tecnológico de Monterrey}
  \city{Ciudad de México}
  \country{México}}

\author{Héctor Reyes}
\email{a01339607@itesm.mx}
\affiliation{%
  \institution{Tecnológico de Monterrey}
  \city{Ciudad de México}
  \country{México}}

\renewcommand{\shortauthors}{Daniela Vignau, Cristopher Cejudo, Héctor Reyes}

\begin{abstract}
  Este reporte busca profundizar en varios aspectos de las bases de datos en memoria, teniendo como foco el sistema de administración de bases de datos (DBMS) {\itshape Kinetica}. También se analiza el rendimiento de la base de datos en cuestión para las operaciones de inserción y consulta.
\end{abstract}

\maketitle

\section{Introducción}

Kinetica es una base de datos en memoria que permite ingerir, analizar y visualizar datos simultáneamente. Es un DBMS único en el sentido de que aprovecha el rendimiento de la unidad de procesamiento gráfico (GPU) para realizar operaciones con más rapidez que las bases de datos tradicionales.

Al tratarse de una base de datos orientada a columnas diseñada para el procesamiento analítico (OLAP), Kinetica está optimizada para manejar grandes volúmenes de datos de alta cardinalidad. Kinetica organiza los datos de forma estructurada, similar a otras bases de datos relacionales, y los almacena en la memoria RAM o VRAM, en el caso de las GPUs. (Kinetica, s.f.)

\section{Desarrollo}

\subsection{Arquitectura del DBMS}

\begin{figure}[ht]
  \centering
  \includegraphics[width=75mm, scale=0.5]{./images/dbms-architecture}
  \caption{Arquitectura del DBMS (Kinetica, s.f.)}
  \Description{Arquitectura del DBMS}
  \label{fig:Arquitectura del DBMS (Kinetica, s.f.)}
\end{figure}

Kinetica cuenta con una arquitectura distribuida diseñada así para el procesamiento de datos a escala. Un clúster de Kinetica, conformado por nodos idénticos, es capaz de ejecutarse en hardware básico, así como en aquellos equipados con GPU. Uno de esos nodos es seleccionado para ser el nodo de agregación principal. En la Fig. \ref{fig:Arquitectura del DBMS (Kinetica, s.f.)} se muestra un diagrama de la arquitectura de Kinetica. (Kinetica, s.f.)

\subsection{Tipo de almacenamiento utilizado}

La interfaz API nativa a Kinetica para el almacenamiento de datos es de tipo objeto; cada uno de ellos es una fila en la tabla. (Kinetica, s.f.)

% Missing citation
\subsection{Representación en memoria}

Dado que el tipo de almacenamiento utilizado por Kinetica es orientado a columnas, la representación en memoria es secuencial. Así, cada registro de una columna va después del otro, e inmediatamente después de terminar esa columna, comienza la siguiente.

\subsection{Mecanismos de compresión}

Es posible aplicar diferentes mecanismos de compresión a las columnas de las tablas de Kinetica. De manera predeterminada, las columnas son almacenadas sin compresión. En caso de que se desee comprimirlas, permanecen en ese estado hasta que son utilizadas. Cuando se recuperan los datos, se realiza una copia temporal de los datos descomprimidos, la cual es descartada una vez que ya no se utiliza. (Kinetica, s.f.)

Kinetica admite cuatro configuraciones de compresión diferentes que varían según su velocidad:

\begin{itemize}
  \item Ninguna (predeterminado)
  \item \verb|snappy|: Altas velocidades de compresión y descompresión
  \item \verb|lz4|: Alta velocidad de compresión, mayor velocidad de descompresión
  \item \verb|lz4hc|: Menores velocidades de compresión y descompresión
\end{itemize}

Kinetica, además, permite la codificación por diccionario, la cual puede ser aplicada a columnas individuales de los siguientes tipos de datos:

\begin{itemize}
  \item \verb|int|
  \item \verb|long|
  \item \verb|date|
  \item \verb|char1 - char256|
\end{itemize}

De esta manera, se almacenan en memoria los valores únicos por cada columna para después ser asociados a su correspondiente registro. Esto elimina el almacenamiento de valores duplicados por columna, reduciendo, así, el uso de la memoria y el espacio en disco requeridos para almacenar los datos. (Kinetica, s.f.)

\subsection{Particionamiento}

Los datos de una tabla pueden ser sometidos a un particionamiento para optimizar el rendimiento y el manejo de datos. Los esquemas de particionamiento permitidos en Kinetica son los siguientes:

\begin{itemize}
  \item {\itshape Rango:} Las particiones por rango de datos se definen a partir de un rango donde todos los registros con una llave de partición de ese rango son asignados a esa partición.
  \item {\itshape Intervalo:} Las particiones por intervalo se definen como intervalos numéricos o intervalos basados en el tiempo. Todos los registros cuya llave de partición está dentro del intervalo, o en el rango inferior, son asignados a esa partición.
  \item {\itshape Lista:} Las particiones por lista pueden ser manuales o automáticas, donde, en general, cuando los registros cuyos valores de la llave de partición estén dentro de la lista prefinida, son asignados a esa partición.
  \item {\itshape Hash:} Las particiones por hash se definen por un número exacto de particiones, donde cada uno de los registros es asignado a una partición basado en el hash de la llave de partición.
  \item {\itshape Series:} El particionamiento por serie segmenta los datos en una secuencia de particiones alocadas de manera dinámica. (Kinetica, s.f.)
\end{itemize}

\subsection{Operaciones DML}

\subsubsection{Operación de inserción}

En lo que respecta a la operación \verb|INSERT|, Kinetica admite dos tipos de formato:

\begin{itemize}
  \item \verb|INSERT INTO...VALUES|: Se utiliza para insertar registros con valores literales en una tabla.
  \begin{lstlisting}
    INSERT INTO example.employee (
      id,
      dept_id,
      manager_id,
      first_name,
      last_name,
      sal,
      hire_date)
    VALUES
        (1, 1, null, 'Anne', 'Arbor', 200000, '2000-01-01')
  \end{lstlisting}
  \item \verb|INSERT INTO...SELECT|: Se utiliza para insertar registros de una tabla existente.
  \begin{lstlisting}
    INSERT INTO example.employee (
      id,
      dept_id,
      manager_id,
      first_name,
      last_name,
      sal)
    SELECT id, dept_id, manager_id, first_name, last_name, sal
    FROM example.employee
    WHERE hire_date >= '2000-01-01'
  \end{lstlisting}
\end{itemize}

De forma predeterminada, Kinetica descartará cualquier registro a insertar cuya llave primaria coincida con la de un registro existente.

\subsubsection{Operación de actualización}

La operación \verb|UPDATE|, por otro lado, permite asignar un nuevo valor constante a una columna mediante el formato \verb|UPDATE...SET...WHERE|.

\begin{lstlisting}
  UPDATE example.employee
  SET
    sal = sal * 1.10,
    manager_id = 3
  WHERE id = 5
\end{lstlisting}

\subsubsection{Operación de eliminación}

Finalmente, la operación \verb|DELETE| permite eliminar registros de una tabla mediante el formato \verb|DELETE FROM...WHERE|. (Kinetica, s.f.)

\begin{lstlisting}
  DELETE
  FROM example.employee
  WHERE id = 6
\end{lstlisting}

\subsection{Buffer diferencial y proceso de mezcla}

No se encontró información sobre la implementación del buffer diferencial y el proceso de mezcla en Kinetica.

\subsection{Reconstrucción de tuplas}

No se encontró información sobre el proceso de reconstrucción de tuplas en Kinetica.

\subsection{Tipos de {\itshape join}}

Con Kinetica, es posible conectar datos relacionados entre dos o más tablas a través de {\itshape join views}. A continuación se enlistan los tipos de {\itshape join} permitidos:

\begin{itemize}
  \item {\itshape Inner:} Regresa los registros que coinciden entre dos tablas.
  \item {\itshape Left:}  Regresa los registros que coinciden entre dos tablas, así como los registros de la tabla izquierda cuyos registros no coinciden con la tabla derecha.
  \item {\itshape Right:} Regresa los registros que coinciden entre dos tablas, así como los registros de la tabla derecha cuyos registros no coinciden con la tabla izquierda.
  \item {\itshape Full outer:} Regresa los registros que coinciden entre dos tablas, así como los que no tienen relación con la otra tabla.
  \item {\itshape Cross:} Regresa todos los registros de una tabla junto con su registro correspondiente de la otra tabla.
\end{itemize}

Asimismo, hay dos tipos de ejecución para los {\itshape joins}:

\begin{itemize}
  \item {\itshape Native joins:} Realiza un aislamiento de la operación {\itshape join} y crea un {\itshape join view} nativo a Kinetica. 
  \item {\itshape SQL joins:} Se realiza automáticamente cuando una base de datos recibe una consulta SQL con la cláusula \verb|JOIN|. 
\end{itemize}

Dependiendo del tipo de {\itshape join} usado, la memoria se verá afectada positiva o negativamente. Kinetica busca constantemente la forma de crear el {\itshape join} más eficiente posible. (Kinetica, s.f.)

\subsection{{\itshape Logging}} 

Kinetica mantiene un registro que almacena información como interacciones de la base de datos, {\itshape startup}/{\itshape shutdown}, errores, etc. Este registro se puede configurar para almacenar información que no está predeterminada. (Kinetica, s.f.)

\subsection{Respaldos y {\itshape recovery}}

Existe una herramienta para la administración, configuración e instalación de Kinetica llamada {\itshape KAgent}, la cual también simplifica el proceso de respaldo y {\itshape recovery} de una base de datos en Kinetica. 

Se puede realizar un respaldo de todos los datos de la base de datos de forma automática —es decir, siguiendo un programa preestablecido— o cuando el usuario así lo requiera. Las copias de seguridad se almacenan localmente para cada uno de los nodos dentro del clúster. (Kinetica, s.f.)

\subsection{Manejo de transacciones}

Debido a la potencia que le brinda la compatibilidad con  GPU, Kinetica rara vez se usa para el manejo de transacciones. Como sistema OLAP, es mejor aprovechado para consultas de análisis de datos junto con otro DBMS de tipo OLTP. (Kinetica, s.f.)

\subsection{{\itshape Cold}/{\itshape Hot Storage}}

Kinetica segmenta el almacenamiento de datos, ya sea temporal o permantente, por niveles o {\itshape tiers}. Hay cinco {\itshape tiers} soportados por Kinetica: 

\begin{itemize}
  \item {\itshape VRAM:}  Compuesto por memoria RAM de GPU en cada nodo del clúster.
  \item {\itshape RAM:}  Compuesto por memoria del sistema en cada nodo del clúster.
  \item {\itshape Caché de disco:}  Sirve como espacio temporal para el intercambio de datos que no caben en la memoria RAM o VRAM.
  \item {\itshape Persist:} Contiene registros que se conservan cada vez que se reinicia la base de datos.
  \item {\itshape Cold Storage:} Se utiliza para almacenar datos a los que se accede con poca frecuencia.
\end{itemize}

En la Fig. \ref{fig:Niveles de almacenamiento (Kinetica, s.f.)} se muestra un diagrama de los diferentes niveles de almacenamiento.

% Missing citation
\begin{figure}[ht]
  \centering
  \includegraphics[width=75mm, scale=0.5]{./images/storage-tiers}
  \caption{Niveles de almacenamiento (Kinetica, s.f.)}
  \Description{Niveles de almacenamiento (Kinetica, s.f.)}
  \label{fig:Niveles de almacenamiento (Kinetica, s.f.)}
\end{figure}

El rendimiento de cada {\itshape tier} es inversamente proporcional a su capacidad de almacenamiento. (Kinetica, s.f.)

\subsection{Manejo de datos históricos}

Kinetica cuenta con un {\itshape streaming data warehouse}, el cual, a diferencia de los {\itshape data warehouses} tradicionales, puede analizar los datos almacenados en tiempo real. De este modo, se obtiene un anáisis que puede ser utilizado de manera innmediata. (Kinetica, s.f.)

\section{Resultados}

A continuación se presenta un análisis sobre los resultados obtenidos al realizar consultas a una base datos sobre Kinetica. Debido a limitaciones relacionadas con la memoria RAM del equipo utilizado y el límite de registros por tabla, se realizó un escalamiento de los datos requeridos con tres inserciones de 500 mil, 1 millón y 5 millones de registros respectivamente.

\begin{figure}[ht]
  \centering
  \includegraphics[width=75mm, scale=0.5]{./images/insertion-stats1.png}
  \caption{Registros insertados por minuto}
  \Description{Registros insertados por minuto}
  \label{fig:Registros insertados por minuto}
\end{figure}

\begin{figure}[ht]
  \centering
  \includegraphics[width=75mm, scale=0.5]{./images/insertion-stats2.png}
  \caption{Velocidad de peticiones y respuesta bytes/sec}
  \Description{Velocidad de peticiones y respuesta bytes/sec}
  \label{fig:Velocidad de peticiones y respuesta bytes/sec}
\end{figure}

\begin{figure}[ht]
  \centering
  \includegraphics[width=75mm, scale=0.5]{./images/insertion-stats3.png}
  \caption{Petición de inserción por segundo}
  \Description{Petición de inserción por segundo}
  \label{fig:Peticion de insercion}
\end{figure}

\clearpage

En las gráficas anteriores podemos observar los tiempos y recursos requeridos para la inserción de 500 mil, 1 millón y 5 millones de registros respectivamente. Se requirió de 7Gb en memoria RAM asignados a Kinetica para lograr la inserción de los 6.5 millones de registros. La inserción de 5 millones tomó aproximadamente 4 minutos en poder completarse.

La tabla utilizada se compuso de los siguientes campos:

\begin{itemize}
  \item id : long
  \item name : string | char128
  \item last : string | char128
  \item gender : string | char64
  \item country : string | char128
\end{itemize}

\subsection{Consulta sobre tabla completa}

Para la realización de esta consulta se realizó el query \verb|SELECT * FROM ki_home.world_population|.

\begin{figure}[ht]
  \centering
  \includegraphics[width=95mm, scale=0.7]{./images/query-select5M.png}
  \caption{Consulta sobre tabla completa sobre 5 millones de registros}
  \Description{Consulta sobre tabla completa 5 millones de registros}
  \label{fig:Consulta sobre tabla completa 5 millones de registros}
\end{figure}

\begin{figure}[ht]
  \centering
  \includegraphics[width=95mm, scale=0.7]{./images/query-select1M.png}
  \caption{Consulta sobre tabla completa sobre 1 millón de registros}
  \Description{Consulta sobre tabla completa 1 millón de registros}
  \label{fig:Consulta sobre tabla completa 1 millon de registros}
\end{figure}

\begin{figure}[ht]
  \centering
  \includegraphics[width=95mm, scale=0.7]{./images/query-select500.png}
  \caption{Consulta sobre tabla completa sobre 500  mil registros}
  \Description{Consulta sobre tabla completa 500 mil registros}
  \label{fig:Consulta sobre tabla completa 500 mil registros}
\end{figure}

\subsection{Consulta haciendo uso de funciones de agregación y agrupamiento}

Para la realización de esta consulta se hizo uso de las funciones {\itshape COUNT(), SUM() y GROUP  BY}. El query ejecutado fue el siguiente \verb|SELECT COUNT(id) AS 'Total_by_gender', SUM(id),| \verb|gender FROM ki_home.world_population GROUP BY gender|.

\begin{figure}[ht]
  \centering
  \includegraphics[width=95mm, scale=0.7]{./images/query-aggregation5M.png}
  \caption{Consulta con funciones de agregación y agrupamiento sobre 5 millones de registros}
  \Description{Consulta con funciones de agregación y agrupamiento sobre 5 millones de registros}
  \label{fig:Consulta con funciones de agregacion y agrupamiento sobre 5 millones de registros}
\end{figure}

\clearpage

\begin{figure}[ht]
  \centering
  \includegraphics[width=95mm, scale=0.7]{./images/query-aggregation1M.png}
  \caption{Consulta con funciones de agregación y agrupamiento sobre 1 millón de registros}
  \Description{Consulta con funciones de agregación y agrupamiento sobre 1 millón de registros}
  \label{fig:Consulta con funciones de agregacion y agrupamiento sobre 1 millon de registros}
\end{figure}

\begin{figure}[ht]
  \centering
  \includegraphics[width=95mm, scale=0.7]{./images/query-aggregation500.png}
  \caption{Consulta con funciones de agregación y agrupamiento sobre 500 mil registros}
  \Description{Consulta con funciones de agregación y agrupamiento sobre 500 mil}
  \label{fig:Consulta con funciones de agregacion y agrupamiento sobre 500 mil}
\end{figure}

\clearpage

\subsection{Consulta con condición de filtrado}

Por último, para la realización de la consulta con condición de filtrado se ejecutó el siguiente query \verb|SELECT * FROM ki_home.world_population WHERE name = 'Daniel'|.

\begin{figure}[ht]
  \centering
  \includegraphics[width=95mm, scale=0.7]{./images/query-filter5M.png}
  \caption{Consulta con condición de filtrado sobre 5 millones de registros}
  \Description{Consulta con condición de filtrado sobre 5 millones de registros}
  \label{fig:Consulta con condicion de filtrado sobre 5 millones de registros}
\end{figure}

\begin{figure}[ht]
  \centering
  \includegraphics[width=95mm, scale=0.7]{./images/query-filter1M.png}
  \caption{Consulta con condición de filtrado sobre 1 millón de registros}
  \Description{Consulta con condición de filtrado sobre 1 millón de registros}
  \label{fig:Consulta con condicion de filtrado sobre 1 millon de registros}
\end{figure}

\clearpage

\begin{figure}[ht]
  \centering
  \includegraphics[width=95mm, scale=0.7]{./images/query-filter500.png}
  \caption{Consulta con condición de filtrado sobre 500 mil registros}
  \Description{Consulta con condición de filtrado sobre 500 mil registros}
  \label{fig:Consulta con condicion de filtrado sobre 500 mil registros}
\end{figure}

\subsection{Tabla Comparativa de Tiempos de Ejecución}

A continuación se presenta una tabla con los tiempos de ejecución de cada operación realizada.

\begin{center}
  \begin{tabular}{||c c c c||} 
  \hline
  Operación & 500 mil registros & 1 millón de registros & 5 millones de registros\\ [0.5ex] 
  \hline\hline
  Inserción & 41s & 1min 27s & 3min 46s \\ 
  \hline
  Consulta Scan & 0.224s & 0.338s & 0.424s \\
  \hline
  Consulta Agregación & 0.216s & 0.513 s& 11.459s \\
  \hline
  Consulta Filtrado & 0.803s & 1.326s & 3.232s \\ [1ex] 
  \hline
 \end{tabular}
\end{center}

\clearpage

\subsection{Gráficas Comparativas de Tiempos de Ejecución}

Con la información anteriormente presentada fueron creadas las siguentes gráficas para su visualización.

\begin{figure}[ht]
  \centering
  \includegraphics[width=95mm, scale=0.7]{./images/insertion-graph.png}
  \caption{Gráfica comparativa de los tiempos de inserción}
  \Description{Gráfica comparativa de los tiempos de inserción}
  \label{fig:Grafica comparativa de los tiempos de insercion}
\end{figure}

\begin{figure}[ht]
  \centering
  \includegraphics[width=95mm, scale=0.7]{./images/querys-graph.png}
  \caption{Gráfica comparativa de los tiempos de consulta}
  \Description{Gráfica comparativa de los tiempos de consulta}
  \label{fig:Grafica comparativa de los tiempos de consulta}
\end{figure}

\section{Conclusiones}

Es posible concluir de los resultados anteriores que Kinetica no es una base de datos diseñada para el manejo de poblaciones tan grandes en un hardware limitado (sin GPU), ya que la memoria RAM fue rápidamente consumida. Es por esto que el equipo se vio obligado a hacer una extrapolación de las poblaciones. 

Dicho esto, los resultados obtenidos indican que, conforme crece el tamaño de la población, tanto el tiempo de inserción como el de las consultas aumenta. 

\begin{thebibliography}{9}
  \bibitem{faq} 
  Kinetica. (s.f.). «{\itshape Frequently Asked Questions}». https://www.kinetica.com/product/faq/
  \bibitem{overview} 
  Kinetica. (s.f.). «{\itshape Overview}».
  https://www.kinetica.com/docs/overview/arch.html
  \bibitem{compression}
  Kinetica. (s.f.). «{\itshape Compression}». https://www.kinetica.com/docs/concepts/compression.html
  \bibitem{dictionary-encoding}
  Kinetica. (s.f.). «{\itshape Dictionary Encoding}». https://www.kinetica.com/docs/concepts/compression.html
  \bibitem{tables}
  Kinetica. (s.f.). «{\itshape Tables}». https://www.kinetica.com/docs/concepts/tables.html
  \bibitem{sql-support}
  Kinetica. (s.f.). «{\itshape SQL Support}». https://www.kinetica.com/docs/concepts/sql.html
  \bibitem{streaming-data-warehouse}
  Kinetica. (s.f.). «{\itshape What Is a Streaming Data Warehouse?}». https://www.kinetica.com/products/why-streaming-data-warehouse/
\end{thebibliography}

\end{document}
\endinput
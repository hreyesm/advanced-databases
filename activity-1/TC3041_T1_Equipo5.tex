\documentclass[acmsmall]{acmart}

\usepackage{graphicx}  % for images

\AtBeginDocument{%
  \providecommand\BibTeX{{%
    \normalfont B\kern-0.5em{\scshape i\kern-0.25em b}\kern-0.8em\TeX}}}

\setcopyright{acmcopyright}
\copyrightyear{2021}
\acmYear{2021}

\acmJournal{JACM}
\acmMonth{1}

\begin{document}

\title{Actividad 1. Bases de datos en memoria}

\author{Daniela Vignau León}
\affiliation{%
  \institution{Tecnológico de Monterrey}
  \country{México}}

\author{Cristopher Cejudo}
\affiliation{%
  \institution{Tecnológico de Monterrey}
  \country{México}}

\author{Héctor Reyes}
\affiliation{%
  \institution{Tecnológico de Monterrey}
  \country{México}}

\renewcommand{\shortauthors}{Daniela Vignau, Cristopher Cejudo, Héctor Reyes}

\begin{abstract}
  Este reporte busca profundizar en varios aspectos de las bases de datos en memoria, teniendo como foco el sistema de administración de bases de datos (DBMS) Kinetica. También se analiza el rendimiento de la base de datos en cuestión para las operaciones de inserción y consulta.
\end{abstract}

\maketitle

\section{Introducción}
Kinetica es una base de datos distribuida en memoria que permite ingerir, analizar y visualizar datos simultáneamente. Es un DBMS único en el sentido de que aprovecha el rendimiento de la unidad de procesamiento gráfico (GPU) para realizar operaciones con más rapidez que las bases de datos tradicionales.

Al tratarse de una base de datos orientada a columnas diseñada para el procesamiento analítico (OLAP), Kinetica está optimizada para manejar grandes volúmenes de datos de alta cardinalidad. Por tanto, no es adecuada como sistema de uso transaccional (OLTP). Kinetica organiza los datos de forma estructurada, similar a otras bases de datos relacionales, y los almacena en la memoria RAM o vRAM, en el caso de las GPUs.

\section{Desarrollo}

\subsection{Arquitectura del DBMS}
\begin{figure}[ht]
temp  \includegraphics[width=75mm, scale=0.5]{./images/dbms-architecture.jpg}
  \caption{Arquitectura del DBMS}
  \label{fig:Arquitectura del DBMS}
\end{figure}

Kinetica cuenta con una arquitectura distribuida diseñada así para el procesamiento de datos a escala. Un clúster de Kinetica, conformado por nodos idénticos, es capaz de ejecutarse en hardware básico, así como en aquellos equipados con GPU. Uno de esos nodos es seleccionado para ser el nodo de agregación principal. En la Fig. \ref{fig:Arquitectura del DBMS} se muestra un diagrama de la arquitectura de Kinetica.

\subsection{Tipo de almacenamiento utilizado}
La interfaz API nativa a Kinetica para el almacenamiento de datos es de tipo objeto; cada uno de ellos es una fila en la tabla.

\subsection{Representación en memoria}
Dado que el tipo de almacenamiento utilizado por Kinetica es por columnas, la representación en memoria es secuencial. Así, cada registro de una columna va después del otro, e inmediatamente después de terminar esa columna, comienza la siguiente.

\subsection{Mecanismos de compresión}

Es posible aplicar diferentes mecanismos de compresión a las columnas de las tablas de Kinetica. De manera predeterminada, las columnas son almacenadas sin compresión. En el caso de que se compriman, permanecen en ese estado hasta que son utilizadas. Cuando se recuperan los datos, se realiza una copia temporal de los datos descomprimidos, la cual es descartada una vez que ya no se utiliza.

Kinetica admite cuatro configuraciones de compresión diferentes que varían en velocidad:

\begin{itemize}
  \item Ninguna (predeterminado)
  \item \verb|snappy|: Altas velocidades de compresión y descompresión. 
  \item \verb|lz4|: Alta velocidad de compresión, mayor velocidad de descompresión.
  \item \verb|lz4hc|: Menores velocidades de compresión y descompresión.
\end{itemize}

\subsection{Particionamiento}
Los datos de una tabla pueden ser sometidos a un particionamiento para optimizar el rendimiento y el manejo de datos. Los esquemas de particionamiento permitidos en Kinetica son los siguientes:

\begin{itemize}
  \item Rango: Las {\itshape particiones por rango} de datos está definido a partir de un rango donde todos los registros con una {\itshape llave de partición} de ese rango, son asignados a esa {\itshape partición}.
  \item Intervalo: Las {\itshape particiones por intervalo} estan definidas como intervalos numéricos o intervalos basados en el tiempo. Todos los registros cuya {\itshape llave de partición} están dentro del intervalo, o en el rango inferior, son asignados a esa {\itshape partición}.
  \item Lista: Las {\itshape particiones por lista} pueden ser manuales o automáticas, donde, de manera general, cuando los registros cuyos valores de la {\itshape llave de partición} estén dentro de la lista prefinida, son añadidos a la {\itshape partición}.
  \item Hash: Las {\itshape particiones por hash} están definidas a través de un número exacto de particiones, donde cada uno de los registros es asignado a una {\itshape partición} basándose en el hash de la {\itshape llave de partición}.
  \item Series: El{\itshape particionamiento por serie}, segmenta los datos en una secuencia de {\itshape particiones} alocadas de manera dinámica.
\end{itemize}

\subsection{Operaciones DML}
\subsection{Buffer diferencial y el proceso de mezcla}
\subsection{Reconstrucción de tuplas}
\subsection{Tipos de {\itshape join}}

Con Kinetica, es posible conectar datos relacionados entre dos o más tablas a través de {\itshape join views}. Los tipos de {\itshape join} permitidos son:

\begin{itemize}
  \item INNER: Regresa los registros que coinciden entre dos tablas.
  \item LEFT:  Regresa los registros que coinciden entre dos tablas, así como también los registros de la {\itshape tabla izquierda} cuyos registros no coinciden con la tabla derecha.
  \item RIGHT: Regresa los registros que coinciden entre dos tablas, así como también los registros de la {\itshape tabla derecha} cuyos registros no coinciden con la tabla izquierda.
  \item FULL OUTER: Regresa los registros que coinciden entre dos tablas, así como aquellos que no tienen ninguna relación con la otra tabla.
  \item Cross: Regresa todos los registros de una tabla junto con su correspondiente registro de la otra tabla.
\end{itemize}

De igual manera, hay dos tipos de ejecución para los {\itshape joins}:

\begin{itemize}
  \item {\itshape Native joins}: Realiza un aislamiento de la operación {\itshape join} y crea un {\itshape join view} nativo de Kinetica. 
  \item SQL {\itshape Joins}: Se realiza de manera automática cuando una base de datos recibe una query de SQL con la cláusula \verb|JOIN|. 
\end{itemize}

Dependiendo del tipo de {\itshape join} utilizado, la memoria tiene un cierto impacto negativo. Kinetica constatemente busca la manera de crear el {\itshape join} más eficiente posible. 

\subsection{Logging}
Kinetica cuenta con un registro el cual almacena información como: las interacciones de la base de datos, {\itshape startup/shutdown}, información de errores y más. Este registro puede ser configurado para que se almacene otra información que no está por default.

\subsection{Respaldos y {\itshape Recovery}}

Existe una herramienta para la administración, configuración e instalación de Kinetica llamada {\itshape KAgent}, la cual también permite simplificar el proceso de respaldo y {\itshape recovery} de una base de datos en Kinetica. 

Todos los datos dentro de la base de datos pueden ser respaldados de manera automática (es decir, siguiendo una agenda preestablecida), o bien cuando el usuario así lo requiera. Los respaldos son almacenados de manera local para cada uno de los nodos dentro del cluster.

\subsection{Manejo de transacciones}
\subsection{Cold/hot store}
\subsection{Manejo de datos históricos}

% Pendiente

\end{document}
\endinput